
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>dsl: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/forbearing/gst/dsl/dsl.go (0.0%)</option>
				
				<option value="file1">github.com/forbearing/gst/dsl/helper.go (9.1%)</option>
				
				<option value="file2">github.com/forbearing/gst/dsl/parser.go (86.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package dsl provides a Domain Specific Language (DSL) for defining REST API designs for Go models.
//
// The DSL allows developers to declaratively specify API configurations for their data models,
// including CRUD operations, endpoints, payload/result types, and various behavioral settings.
// It supports automatic code generation for services, controllers, and API routes based on
// the defined specifications.
//
// Basic Usage:
//
//        type User struct {
//                Name string
//                Email string
//                model.Base  // Embeds base model fields
//        }
//
//        func (User) Design() {
//                // Enable API generation (default: true)
//                Enabled(true)
//
//                // Set custom endpoint (default: lowercase model name)
//                Endpoint("users")
//
//                // Add path parameter for dynamic routing
//                Param("user")  // Creates routes like /api/users/:user
//
//                // Enable database migration (default: false)
//                Migrate(true)
//
//                // Define alternative routes for different access patterns
//                Route("public/users", func() {
//                        List(func() { Enabled(true); Public(true) })
//                        Get(func() { Enabled(true); Public(true) })
//                })
//
//                // Configure Create operation
//                Create(func() {
//                        Enabled(true)
//                        Service(true)   // Generate service code
//                        Public(false)   // Internal API only
//                        Payload[CreateUserRequest]()
//                        Result[*User]()
//                })
//
//                // Configure other operations...
//                Update(func() { Enabled(true) })
//                Delete(func() { Enabled(true) })
//                List(func() { Enabled(true) })
//                Get(func() { Enabled(true) })
//        }
//
// Supported Operations:
//   - Create, Update, Delete, Patch: Single record operations
//   - CreateMany, UpdateMany, DeleteMany, PatchMany: Batch operations
//   - List, Get: Read operations
//   - Import, Export: Data transfer operations
//
// Model Types:
//   - Models with model.Base: Full-featured models with database persistence
//   - Models with model.Empty: Lightweight models without database migration
package dsl

import (
        "github.com/forbearing/gst/types/consts"
)

// Enabled controls whether API generation is enabled for the model.
// When set to false, no API code will be generated for this model.
// Default: true
func Enabled(bool) {<span class="cov0" title="0">}</span>

// Endpoint sets a custom endpoint path for the model's API routes.
// If not specified, defaults to the lowercase version of the model name.
// Leading slashes are automatically removed and forward slashes are replaced with hyphens.
// Example: Endpoint("users") for a User model, Endpoint("/iam/users") becomes "iam-users"
func Endpoint(string) {<span class="cov0" title="0">}</span>

// Param defines a path parameter for dynamic routing in RESTful APIs.
// It adds a URL parameter segment to the endpoint, enabling hierarchical resource access.
// The parameter is automatically propagated to child resources in nested structures,
// allowing parent resource parameters to be inherited by child endpoints.
//
// Parameter Format:
//   - Simple name: Param("user") creates ":user" parameter
//   - Bracketed format: Param("{user}") also creates ":user" parameter
//
// Route Generation Examples:
//   - Param("user") transforms /api/users to /api/users/:user
//   - Param("app") transforms /api/namespaces/apps to /api/namespaces/apps/:app
//   - Param("env") transforms /api/namespaces/apps/envs to /api/namespaces/apps/envs/:env
//
// Parameter Propagation:
// When using hierarchical models (namespace -&gt; app -&gt; env), parent parameters are
// automatically propagated to child resources:
//   - /api/namespaces/:namespace/apps/:app/envs/:env
//   - Child resources inherit all parent path parameters
//
// Common Use Cases:
//   - namespace: Param("namespace") or Param("ns") for multi-tenant applications
//   - app: Param("app") for application-scoped resources
//   - env: Param("env") for environment-specific configurations
//
// The parameter creates RESTful nested resource patterns, enabling hierarchical API designs
// where child resources are scoped under parent resources through URL path parameters.
func Param(string) {<span class="cov0" title="0">}</span>

// Route defines an alternative API route for the model beyond the default hierarchical route.
// This allows a resource to be accessible through multiple API endpoints, providing flexibility
// for different access patterns and use cases.
//
// The function accepts two parameters:
//   - path: The route path string (e.g., "apps", "config/apps"). Leading slashes are automatically removed.
//   - config: A function that defines which operations are enabled for this route
//
// The function can be called multiple times within a Design() method to add multiple alternative routes.
// Each call adds a new route to the model's API endpoints without overriding existing ones.
//
// Route Format:
//   - Simple path: Route("apps", func() {...}) creates /api/apps
//   - Nested path: Route("config/apps", func() {...}) creates /api/config/apps
//   - Custom path: Route("admin/applications", func() {...}) creates /api/admin/applications
//   - Leading slash removed: Route("/config/apps", func() {...}) becomes "config/apps"
//
// Configuration Function:
// The second parameter is a function that defines which operations are available for this route.
// You can configure List, Get, Create, Update, Delete, Patch operations within this function:
//
//        Route("/config/apps", func() {
//            List(func() {
//                Enabled(true)
//                Service(true)
//            })
//            Get(func() {
//                Enabled(true)
//                Service(true)
//            })
//        })
//
// Route Generation:
// For a route path like "/config/apps" with Param("app"), the following routes are generated:
//   - /api/config/apps (for List operations)
//   - /api/config/apps/:app (for Get, Update, Delete, Patch operations)
//
// Usage Examples:
//   - Route("apps", func() {...}) - Global app listing endpoint
//   - Route("config/apps", func() {...}) - Configuration-scoped app endpoint
//   - Route("public/apps", func() {...}) - Public app directory endpoint
//
// Common Use Cases:
//   - Global resource access: Access resources without namespace/parent constraints
//   - Alternative endpoints: Provide different API paths for the same resource
//   - Cross-cutting concerns: Admin, public, or system-level access patterns
//   - API versioning: Different route structures for API evolution
//
// Multiple Routes Example:
//
//        func (App) Design() {
//            Endpoint("apps")
//            Param("app")
//            Route("apps", func() {
//                List(func() { Enabled(true) })
//                Get(func() { Enabled(true) })
//            })
//            Route("config/apps", func() {
//                List(func() { Enabled(true); Service(true) })
//                Get(func() { Enabled(true); Service(true) })
//            })
//        }
//
// This creates multiple API endpoints for the same model:
//   - /api/namespaces/:ns/apps (default hierarchical route)
//   - /api/apps and /api/apps/:app (additional global route)
//   - /api/config/apps and /api/config/apps/:app (additional config route)
func Route(string, func()) {<span class="cov0" title="0">}</span>

// Migrate controls whether database migration should be performed for this model.
// When true, the model's table structure will be created/updated in the database.
// Default: false
func Migrate(bool) {<span class="cov0" title="0">}</span>

// Service controls whether service layer code should be generated for the current action.
// This affects the generation of business logic layer code.
// Default: false
func Service(bool) {<span class="cov0" title="0">}</span>

// Public controls whether the current action requires authentication/authorization.
// When false, the action will be processed by auth middleware if registered via middleware.RegisterAuth.
// When true, the action is publicly accessible without authentication.
// Default: false (requires authentication)
func Public(bool) {<span class="cov0" title="0">}</span>

// Payload specifies the request payload type for the current action.
// The type parameter T defines the structure of incoming request data.
// Example: Payload[CreateUserRequest]() or Payload[*User]()
func Payload[T any]() {<span class="cov0" title="0">}</span>

// Result specifies the response result type for the current action.
// The type parameter T defines the structure of outgoing response data.
// Example: Result[*User]() or Result[UserResponse]()
func Result[T any]() {<span class="cov0" title="0">}</span>

// Create defines the configuration for the create operation.
// The function parameter allows setting Enabled, Service, Public, Payload, and Result.
// Example: Create(func() { Enabled(true); Payload[CreateUserRequest](); Result[*User]() })
func Create(func()) {<span class="cov0" title="0">}</span>

// Delete defines the configuration for the delete operation.
// Typically used for soft or hard deletion of single records.
func Delete(func()) {<span class="cov0" title="0">}</span>

// Update defines the configuration for the update operation.
// Used for full record updates, replacing all fields.
func Update(func()) {<span class="cov0" title="0">}</span>

// Patch defines the configuration for the patch operation.
// Used for partial record updates, modifying only specified fields.
func Patch(func()) {<span class="cov0" title="0">}</span>

// List defines the configuration for the list operation.
// Used for retrieving multiple records with optional filtering and pagination.
func List(func()) {<span class="cov0" title="0">}</span>

// Get defines the configuration for the get operation.
// Used for retrieving a single record by identifier.
func Get(func()) {<span class="cov0" title="0">}</span>

// CreateMany defines the configuration for batch create operations.
// Allows creating multiple records in a single request.
func CreateMany(func()) {<span class="cov0" title="0">}</span>

// DeleteMany defines the configuration for batch delete operations.
// Allows deleting multiple records in a single request.
func DeleteMany(func()) {<span class="cov0" title="0">}</span>

// UpdateMany defines the configuration for batch update operations.
// Allows updating multiple records in a single request.
func UpdateMany(func()) {<span class="cov0" title="0">}</span>

// PatchMany defines the configuration for batch patch operations.
// Allows partially updating multiple records in a single request.
func PatchMany(func()) {<span class="cov0" title="0">}</span>

// Import defines the configuration for data import operations.
// Used for bulk data ingestion from external sources.
func Import(func()) {<span class="cov0" title="0">}</span>

// Export defines the configuration for data export operations.
// Used for bulk data extraction to external formats.
func Export(func()) {<span class="cov0" title="0">}</span>

// Design represents the complete API design configuration for a model.
// It contains global settings and individual action configurations.
// This struct is populated by parsing the model's Design() method.
type Design struct {
        // Enabled indicates whether API generation is enabled for this model.
        // Default: true
        Enabled bool

        // Endpoint specifies the URL path segment for this model's API routes.
        // Defaults to the lowercase version of the model name.
        // Used by the router to construct API endpoints.
        Endpoint string

        // Param contains the path parameter name for dynamic routing.
        // The parameter will be inserted as ":param" in the generated route paths.
        // Parameters are automatically propagated to child resources in nested structures,
        // allowing parent resource parameters to be inherited by child endpoints.
        //
        // Usage Examples:
        //   - Param("user") generates routes like /api/users/:user
        //   - Param("app") generates routes like /api/namespaces/apps/:app
        //   - Param("env") generates routes like /api/namespaces/apps/envs/:env
        //
        // Parameter Propagation:
        // In hierarchical models (namespace -&gt; app -&gt; env), parent parameters are
        // automatically propagated: /api/namespaces/:namespace/apps/:app/envs/:env
        //
        // Common Use Cases:
        //   - "namespace" or "ns": for multi-tenant applications
        //   - "app": for application-scoped resources
        //   - "env": for environment-specific configurations
        //
        // Default: "" (no parameter)
        Param string

        // routes contains alternative API routes for this model beyond the default hierarchical route.
        // Each route allows the resource to be accessible through alternative API endpoints,
        // providing flexibility for different access patterns and use cases.
        //
        // Map Structure:
        //   - Key: Route path string (e.g., "apps", "config/apps", "public/apps")
        //   - Value: Slice of Action configurations for operations enabled on this route
        //
        // Route Examples:
        //   - "apps" creates /api/apps and /api/apps/:param (if Param is defined)
        //   - "config/apps" creates /api/config/apps and /api/config/apps/:param
        //   - "public/apps" creates /api/public/apps and /api/public/apps/:param
        //
        // Action Configuration:
        // Each route can have different operations enabled. For example:
        //   - Route "apps" might only enable List and Get operations
        //   - Route "admin/apps" might enable all CRUD operations
        //   - Route "public/apps" might only enable List operation
        //
        // Multiple routes can be defined by calling Route() multiple times in Design().
        // Each alternative route can have its own set of enabled operations and configurations.
        //
        // Usage in Design():
        //   Route("/config/apps", func() {
        //       List(func() { Enabled(true); Service(false) })
        //       Get(func() { Enabled(true); Service(false) })
        //   })
        //
        // This populates routes["/config/apps"] with List and Get Action configurations.
        //
        // Default: nil (no alternative routes)
        routes map[string][]*Action

        // Migrate indicates whether database migration should be performed.
        // When true, the model's table structure will be created/updated.
        // Default: false
        Migrate bool

        // IsEmpty indicates if the model contains a model.Empty field.
        // Models with model.Empty are lightweight and typically don't require migration.
        IsEmpty bool

        // Single record operations
        Create *Action // Create operation configuration
        Delete *Action // Delete operation configuration
        Update *Action // Update operation configuration (full replacement)
        Patch  *Action // Patch operation configuration (partial update)
        List   *Action // List operation configuration (retrieve multiple)
        Get    *Action // Get operation configuration (retrieve single)

        // Batch operations
        CreateMany *Action // Batch create operation configuration
        DeleteMany *Action // Batch delete operation configuration
        UpdateMany *Action // Batch update operation configuration
        PatchMany  *Action // Batch patch operation configuration

        // Data transfer operations
        Import *Action // Import operation configuration
        Export *Action // Export operation configuration
}

// Range iterates over all enabled actions in the Design and calls the provided function
// for each one. The function receives the endpoint, action for each enabled action.
//
// Parameters:
//   - fn: Callback function that receives (endpoint, action) for each enabled action
//
// The iteration order is fixed: Create, Delete, Update, Patch, List, Get,
// CreateMany, DeleteMany, UpdateMany, PatchMany, Import, Export.
//
// Example:
//
//        design.Range(func(route string, action *Action) {
//                fmt.Printf("Generating %s for %s\n", action.Phase.MethodName(), route)
//        })
func (d *Design) Range(fn func(route string, action *Action)) <span class="cov0" title="0">{ rangeAction(d, fn) }</span>

// Action represents the configuration for a specific API operation.
// Each operation (Create, Update, Delete, etc.) has its own Action configuration.
type Action struct {
        // Enabled indicates whether this specific action should be generated.
        // Default: false (actions must be explicitly enabled)
        Enabled bool

        // Service indicates whether service layer code should be generated for this action.
        // The service layer contains business logic and data access code.
        // Default: false
        Service bool

        // Public indicates whether this action requires authentication/authorization.
        // When false, the action will be processed by auth middleware if registered via middleware.RegisterAuth.
        // When true, the action is publicly accessible without authentication.
        // Default: false (requires authentication)
        Public bool

        // Payload specifies the type name for the request payload.
        // This determines the structure of incoming request data.
        // Example: "CreateUserRequest", "*User", "User"
        Payload string

        // Result specifies the type name for the response result.
        // This determines the structure of outgoing response data.
        // Example: "*User", "UserResponse", "[]User"
        Result string

        // The phase of the action
        // not part of DSL, just used to identify the current Action.
        Phase consts.Phase
}

var methodList = []string{
        "Enabled",
        "Endpoint",
        "Param",
        "Route",
        "Migrate",
        "Payload",
        "Result",

        consts.PHASE_CREATE.MethodName(),
        consts.PHASE_DELETE.MethodName(),
        consts.PHASE_UPDATE.MethodName(),
        consts.PHASE_PATCH.MethodName(),
        consts.PHASE_LIST.MethodName(),
        consts.PHASE_GET.MethodName(),

        consts.PHASE_CREATE_MANY.MethodName(),
        consts.PHASE_DELETE_MANY.MethodName(),
        consts.PHASE_UPDATE_MANY.MethodName(),
        consts.PHASE_PATCH_MANY.MethodName(),

        consts.PHASE_IMPORT.MethodName(),
        consts.PHASE_EXPORT.MethodName(),
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package dsl

import (
        "slices"
        "strings"
)

// rangeAction iterates through all actions in a Design and calls the provided function
// for each enabled action. This is a helper function used by Design.Range().
//
// The function iterates through actions in a predefined order and only processes
// actions that are enabled (action.Enabled == true).
//
// Parameters:
//   - d: The Design containing actions to iterate over
//   - fn: Callback function that receives (endpoint, action) for each enabled action
//
// Iteration order:
//  1. Single record operations: Create, Delete, Update, Patch, List, Get
//  2. Batch operations: CreateMany, DeleteMany, UpdateMany, PatchMany
//  3. Data transfer operations: Import, Export
//
// For each enabled action, the callback receives:
//   - endpoint: The API endpoint path from the Design
//   - action: The Action configuration
//
// Example:
//
//        rangeAction(design, func(route string, a *Action,) {
//                fmt.Printf("%s %s payload=%s result=%s\n", action.Phase.MethodName(), route, a.Payload, a.Result)
//        })
func rangeAction(d *Design, fn func(string, *Action)) <span class="cov0" title="0">{
        if d == nil || fn == nil || !d.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if d.Create.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.Create)
        }</span>
        <span class="cov0" title="0">if d.Delete.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.Delete)
        }</span>
        <span class="cov0" title="0">if d.Update.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.Update)
        }</span>
        <span class="cov0" title="0">if d.Patch.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.Patch)
        }</span>
        <span class="cov0" title="0">if d.List.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.List)
        }</span>
        <span class="cov0" title="0">if d.Get.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.Get)
        }</span>
        <span class="cov0" title="0">if d.CreateMany.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.CreateMany)
        }</span>
        <span class="cov0" title="0">if d.DeleteMany.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.DeleteMany)
        }</span>
        <span class="cov0" title="0">if d.UpdateMany.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.UpdateMany)
        }</span>
        <span class="cov0" title="0">if d.PatchMany.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.PatchMany)
        }</span>
        <span class="cov0" title="0">if d.Import.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.Import)
        }</span>
        <span class="cov0" title="0">if d.Export.Enabled </span><span class="cov0" title="0">{
                fn(d.Endpoint, d.Export)
        }</span>

        <span class="cov0" title="0">for route, action := range d.routes </span><span class="cov0" title="0">{
                for _, a := range action </span><span class="cov0" title="0">{
                        if a.Enabled </span><span class="cov0" title="0">{
                                fn(route, a)
                        }</span>
                }
        }
}

// is checks if the given name is a valid DSL method name.
// It verifies against the predefined list of supported DSL methods.
//
// Parameters:
//   - name: The method name to check
//
// Returns:
//   - bool: true if the name is a valid DSL method, false otherwise
func is(name string) bool <span class="cov8" title="1">{
        return slices.Contains(methodList, name)
}</span>

// trimQuote removes surrounding quotes from a string.
// It trims double quotes ("), single quotes ('), and backticks (`) from both ends.
//
// Parameters:
//   - str: The string to trim quotes from
//
// Returns:
//   - string: The string with surrounding quotes removed
//
// Example:
//
//        trimQuote(`"hello"`) returns "hello"
//        trimQuote("'world'") returns "world"
func trimQuote(str string) string <span class="cov8" title="1">{
        return strings.TrimFunc(str, func(r rune) bool </span><span class="cov8" title="1">{
                return r == '`' || r == '"' || r == '\''
        }</span>)
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package dsl

import (
        "fmt"
        "go/ast"
        "go/token"
        "slices"
        "strings"

        "github.com/forbearing/gst/types/consts"
)

// Parse analyzes a Go source file and extracts DSL design information from models.
// It looks for structs that have a Design() method and parses the DSL calls within that method.
//
// The parser identifies models by finding structs that embed either model.Base or model.Empty,
// then locates their Design() method and analyzes the DSL function calls to build the Design configuration.
//
// Parameters:
//   - file: The parsed AST file node to analyze
//   - endpoint: Optional endpoint override - if provided, will overwrite the default endpoint for enabled designs
//
// Returns:
//   - map[string]*Design: A map where keys are model names and values are their parsed Design configurations
//
// Example usage:
//
//        designs := Parse(fileNode, "custom-endpoint")
//        for modelName, design := range designs {
//                fmt.Printf("Model %s has endpoint: %s\n", modelName, design.Endpoint)
//        }
//
// The parser supports various DSL patterns:
//   - Global settings: Enabled(), Endpoint("path"), Migrate(true)
//   - Action configuration: Create().Enabled(true).Payload[Type].Result[Type]
//   - Service and visibility: Service(true), Public(false)
func Parse(file *ast.File, endpoint string) map[string]*Design <span class="cov8" title="1">{
        designBase, designEmpty := parse(file)

        // If struct contains model.Base and model.Empty, then remove it from designEmpty.
        // model.Base has more priority than model.Empty.
        for name := range designBase </span><span class="cov8" title="1">{
                delete(designEmpty, name)
        }</span>

        <span class="cov8" title="1">m := make(map[string]*Design)
        for name, fnDecl := range designBase </span><span class="cov8" title="1">{
                design := parseDesign(fnDecl)
                m[name] = design
        }</span>
        <span class="cov8" title="1">for name, fnDecl := range designEmpty </span><span class="cov8" title="1">{
                design := parseDesign(fnDecl)
                // the struct has field model.Empty always should be not migrated,
                // and mark `IsEmpty` field to true
                design.Migrate = false
                design.IsEmpty = true
                m[name] = design
        }</span>

        // set the default values for Design
        // Default action, the action always not nil,
        // Action default value:
        //        Enabled default to "true"
        //        Service default to "false"
        <span class="cov8" title="1">for name, design := range m </span><span class="cov8" title="1">{
                // Default endpoint is the lower case of the model name.
                if len(design.Endpoint) == 0 </span><span class="cov8" title="1">{
                        design.Endpoint = strings.ToLower(name)
                }</span>

                <span class="cov8" title="1">if design.Create == nil </span><span class="cov8" title="1">{
                        design.Create = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.Delete == nil </span><span class="cov8" title="1">{
                        design.Delete = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.Update == nil </span><span class="cov8" title="1">{
                        design.Update = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.Patch == nil </span><span class="cov8" title="1">{
                        design.Patch = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.List == nil </span><span class="cov8" title="1">{
                        design.List = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.Get == nil </span><span class="cov8" title="1">{
                        design.Get = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.CreateMany == nil </span><span class="cov8" title="1">{
                        design.CreateMany = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.DeleteMany == nil </span><span class="cov8" title="1">{
                        design.DeleteMany = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.UpdateMany == nil </span><span class="cov8" title="1">{
                        design.UpdateMany = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.PatchMany == nil </span><span class="cov8" title="1">{
                        design.PatchMany = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.Import == nil </span><span class="cov8" title="1">{
                        design.Import = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>
                <span class="cov8" title="1">if design.Export == nil </span><span class="cov8" title="1">{
                        design.Export = &amp;Action{Payload: starName(name), Result: starName(name)}
                }</span>

                <span class="cov8" title="1">initDefaultAction(name, design.Create)
                initDefaultAction(name, design.Delete)
                initDefaultAction(name, design.Update)
                initDefaultAction(name, design.Patch)
                initDefaultAction(name, design.List)
                initDefaultAction(name, design.Get)
                initDefaultAction(name, design.CreateMany)
                initDefaultAction(name, design.DeleteMany)
                initDefaultAction(name, design.UpdateMany)
                initDefaultAction(name, design.PatchMany)
                initDefaultAction(name, design.Import)
                initDefaultAction(name, design.Export)
                for _, actions := range design.routes </span><span class="cov8" title="1">{
                        for _, action := range actions </span><span class="cov8" title="1">{
                                initDefaultAction(name, action)
                        }</span>
                }

                <span class="cov8" title="1">if len(endpoint) &gt; 0 &amp;&amp; design.Enabled </span><span class="cov0" title="0">{
                        design.Endpoint = endpoint
                }</span>

                <span class="cov8" title="1">m[name] = design</span>
        }

        <span class="cov8" title="1">return m</span>
}

// initDefaultAction initializes default payload and result values for an enabled action.
// If the action is enabled but has empty Payload or Result fields, they are set to
// the pointer type of the model name (e.g., "*User" for model "User").
//
// Parameters:
//   - modelName: The name of the model (e.g., "User")
//   - action: The action to initialize defaults for
//
// This function only modifies enabled actions. For disabled actions, the Payload
// and Result fields remain unchanged.
func initDefaultAction(modelName string, action *Action) <span class="cov8" title="1">{
        if action.Enabled </span><span class="cov8" title="1">{
                if len(action.Payload) == 0 </span><span class="cov8" title="1">{
                        action.Payload = starName(modelName)
                }</span>
                <span class="cov8" title="1">if len(action.Result) == 0 </span><span class="cov8" title="1">{
                        action.Result = starName(modelName)
                }</span>
        }
}

// parse analyzes an AST file to find all models and their Design method declarations.
// It identifies models by looking for structs that embed model.Base or model.Empty,
// then searches for their corresponding Design() method declarations.
//
// Parameters:
//   - file: The AST file node to analyze
//
// Returns:
//   - First map: Models with model.Base embedding (modelName -&gt; Design method AST node)
//   - Second map: Models with model.Empty embedding (modelName -&gt; Design method AST node)
//
// If a model doesn't have a Design() method, the corresponding value in the map is nil.
// This allows the caller to generate default design configurations for such models.
func parse(file *ast.File) (map[string]*ast.FuncDecl, map[string]*ast.FuncDecl) <span class="cov8" title="1">{
        designBase := make(map[string]*ast.FuncDecl)
        designEmpty := make(map[string]*ast.FuncDecl)
        if file == nil </span><span class="cov0" title="0">{
                return designBase, designEmpty
        }</span>

        <span class="cov8" title="1">modelBase := FindAllModelBase(file)
        modelEmpty := FindAllModelEmpty(file)
        // Every model should always has a *ast.FuncDecl,
        // If model has no "Design" method, then the value is nil.
        // It's convenient to generate a default design for the model.
        for _, model := range modelBase </span><span class="cov8" title="1">{
                designBase[model] = nil
        }</span>
        <span class="cov8" title="1">for _, model := range modelEmpty </span><span class="cov8" title="1">{
                designEmpty[model] = nil
        }</span>

        <span class="cov8" title="1">for _, decl := range file.Decls </span><span class="cov8" title="1">{
                if fn, ok := decl.(*ast.FuncDecl); ok &amp;&amp; fn != nil </span><span class="cov8" title="1">{
                        if fn.Name == nil || len(fn.Name.Name) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if the model has method "Design"
                        <span class="cov8" title="1">if fn.Name.Name != "Design" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Check if the method receiver name is the model name.
                        <span class="cov8" title="1">if fn.Recv == nil || len(fn.Recv.List) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">var recvName string
                        switch t := fn.Recv.List[0].Type.(type) </span>{
                        case *ast.Ident:<span class="cov8" title="1">
                                if t != nil </span><span class="cov8" title="1">{
                                        recvName = t.Name
                                }</span>
                        case *ast.StarExpr:<span class="cov8" title="1">
                                if ident, ok := t.X.(*ast.Ident); ok &amp;&amp; ident != nil </span><span class="cov8" title="1">{
                                        recvName = ident.Name
                                }</span>
                        }
                        <span class="cov8" title="1">if slices.Contains(modelBase, recvName) </span><span class="cov8" title="1">{
                                designBase[recvName] = fn
                        }</span>
                        <span class="cov8" title="1">if slices.Contains(modelEmpty, recvName) </span><span class="cov8" title="1">{
                                designEmpty[recvName] = fn
                        }</span>
                }
        }

        <span class="cov8" title="1">return designBase, designEmpty</span>
}

// parseDesign parses a Design method's AST declaration and extracts the DSL configuration.
// It analyzes the function body to find DSL calls like Enabled(), Endpoint(), Migrate(),
// and action configurations like Create().Enabled(true).Payload[Type].
//
// Parameters:
//   - fn: The AST function declaration for the Design() method
//
// Returns:
//   - *Design: The parsed design configuration with default values applied
//
// If fn is nil or has no body, returns a default Design with Enabled=true and Migrate=false.
// The parser recognizes various DSL patterns and converts them into the Design structure.
func parseDesign(fn *ast.FuncDecl) *Design <span class="cov8" title="1">{
        defaults := &amp;Design{Enabled: true, Migrate: false}
        // model don't have "Design" method, so returns the default design values.
        if fn == nil || fn.Body == nil || len(fn.Body.List) == 0 </span><span class="cov8" title="1">{
                return defaults
        }</span>
        <span class="cov8" title="1">stmts := fn.Body.List

        for _, stmt := range stmts </span><span class="cov8" title="1">{
                callExpr, ok := stmt.(*ast.ExprStmt)
                if !ok || callExpr == nil || callExpr.X == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">call, ok := callExpr.X.(*ast.CallExpr)
                if !ok || call == nil || call.Fun == nil || len(call.Args) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var funcName string
                switch fun := call.Fun.(type) </span>{
                case *ast.Ident:<span class="cov8" title="1">
                        if fun == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">funcName = fun.Name</span>
                case *ast.SelectorExpr:<span class="cov8" title="1">
                        if fun == nil || fun.Sel == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">funcName = fun.Sel.Name</span>
                default:<span class="cov0" title="0">
                        continue</span>
                }
                <span class="cov8" title="1">if !is(funcName) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Parse "Enabled()".
                <span class="cov8" title="1">if funcName == "Enabled" &amp;&amp; len(call.Args) == 1 </span><span class="cov8" title="1">{
                        if arg, ok := call.Args[0].(*ast.Ident); ok &amp;&amp; arg != nil </span><span class="cov8" title="1">{
                                defaults.Enabled = arg.Name == "true"
                        }</span>
                }

                // Parse "Endpoint()".
                <span class="cov8" title="1">if funcName == "Endpoint" &amp;&amp; len(call.Args) == 1 </span><span class="cov8" title="1">{
                        if arg, ok := call.Args[0].(*ast.BasicLit); ok &amp;&amp; arg != nil &amp;&amp; arg.Kind == token.STRING </span><span class="cov8" title="1">{
                                defaults.Endpoint = trimQuote(arg.Value)
                                defaults.Endpoint = strings.TrimLeft(defaults.Endpoint, "/")
                                defaults.Endpoint = strings.ReplaceAll(defaults.Endpoint, "/", "-")
                        }</span>
                }

                // Parse "Migrate()".
                <span class="cov8" title="1">if funcName == "Migrate" &amp;&amp; len(call.Args) == 1 </span><span class="cov8" title="1">{
                        if arg, ok := call.Args[0].(*ast.Ident); ok &amp;&amp; arg != nil </span><span class="cov8" title="1">{
                                defaults.Migrate = arg.Name == "true"
                        }</span>
                }

                // Parse "Param()".
                <span class="cov8" title="1">if funcName == "Param" &amp;&amp; len(call.Args) == 1 </span><span class="cov8" title="1">{
                        if arg, ok := call.Args[0].(*ast.BasicLit); ok &amp;&amp; arg != nil &amp;&amp; arg.Kind == token.STRING </span><span class="cov8" title="1">{
                                defaults.Param = trimQuote(arg.Value)
                                defaults.Param = strings.TrimFunc(defaults.Param, func(r rune) bool </span><span class="cov8" title="1">{
                                        return r == ' ' || r == '{' || r == '}' || r == '[' || r == ']' || r == ':'
                                }</span>)
                                <span class="cov8" title="1">defaults.Param = ":" + defaults.Param</span>
                        }
                }

                // Parse "Route()".
                // Example:
                //
                // Route("/config/apps", func() {
                //         List(func() {
                //                 Enabled(true)
                //                 Service(true)
                //         })
                //         Get(func() {
                //                 Enabled(true)
                //                 Service(true)
                //         })
                // })
                <span class="cov8" title="1">if funcName == "Route" &amp;&amp; len(call.Args) == 2 </span><span class="cov8" title="1">{
                        var route string
                        if arg, ok := call.Args[0].(*ast.BasicLit); ok &amp;&amp; arg != nil &amp;&amp; arg.Kind == token.STRING </span><span class="cov8" title="1">{
                                route = trimQuote(arg.Value)
                                route = strings.TrimLeft(route, "/")
                        }</span>
                        <span class="cov8" title="1">if len(route) &gt; 0 </span><span class="cov8" title="1">{
                                if defaults.routes == nil </span><span class="cov8" title="1">{
                                        defaults.routes = make(map[string][]*Action)
                                }</span>
                                <span class="cov8" title="1">if flit, ok := call.Args[1].(*ast.FuncLit); ok &amp;&amp; flit != nil &amp;&amp; flit.Body != nil </span><span class="cov8" title="1">{
                                        for _, stmt := range flit.Body.List </span><span class="cov8" title="1">{
                                                expr, ok := stmt.(*ast.ExprStmt)
                                                if !ok || expr == nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov8" title="1">call_, ok := expr.X.(*ast.CallExpr)
                                                if !ok || call_ == nil || call_.Fun == nil || len(call_.Args) == 0 </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                <span class="cov8" title="1">var funName_ string
                                                switch fun := call_.Fun.(type) </span>{
                                                case *ast.Ident:<span class="cov8" title="1">
                                                        if fun == nil </span><span class="cov0" title="0">{
                                                                continue</span>
                                                        }
                                                        <span class="cov8" title="1">funName_ = fun.Name</span>
                                                case *ast.SelectorExpr:<span class="cov0" title="0">
                                                        if fun == nil || fun.Sel == nil </span><span class="cov0" title="0">{
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">funName_ = fun.Sel.Name</span>
                                                default:<span class="cov0" title="0">
                                                        continue</span>
                                                }
                                                <span class="cov8" title="1">if !is(funName_) </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_CREATE, funName_, call_.Args[0]); e </span><span class="cov8" title="1">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_DELETE, funName_, call_.Args[0]); e </span><span class="cov0" title="0">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_UPDATE, funName_, call_.Args[0]); e </span><span class="cov8" title="1">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_PATCH, funName_, call_.Args[0]); e </span><span class="cov8" title="1">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_LIST, funName_, call_.Args[0]); e </span><span class="cov8" title="1">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_GET, funName_, call_.Args[0]); e </span><span class="cov8" title="1">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_CREATE_MANY, funName_, call_.Args[0]); e </span><span class="cov8" title="1">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_DELETE_MANY, funName_, call_.Args[0]); e </span><span class="cov0" title="0">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_UPDATE_MANY, funName_, call_.Args[0]); e </span><span class="cov0" title="0">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_PATCH_MANY, funName_, call_.Args[0]); e </span><span class="cov0" title="0">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_IMPORT, funName_, call_.Args[0]); e </span><span class="cov0" title="0">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_EXPORT, funName_, call_.Args[0]); e </span><span class="cov0" title="0">{
                                                        defaults.routes[route] = append(defaults.routes[route], act)
                                                }</span>
                                        }
                                }
                        }
                }

                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_CREATE, funcName, call.Args[0]); e </span><span class="cov8" title="1">{
                        defaults.Create = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_DELETE, funcName, call.Args[0]); e </span><span class="cov8" title="1">{
                        defaults.Delete = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_UPDATE, funcName, call.Args[0]); e </span><span class="cov8" title="1">{
                        defaults.Update = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_PATCH, funcName, call.Args[0]); e </span><span class="cov8" title="1">{
                        defaults.Patch = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_LIST, funcName, call.Args[0]); e </span><span class="cov8" title="1">{
                        defaults.List = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_GET, funcName, call.Args[0]); e </span><span class="cov0" title="0">{
                        defaults.Get = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_CREATE_MANY, funcName, call.Args[0]); e </span><span class="cov0" title="0">{
                        defaults.CreateMany = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_DELETE_MANY, funcName, call.Args[0]); e </span><span class="cov0" title="0">{
                        defaults.DeleteMany = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_UPDATE_MANY, funcName, call.Args[0]); e </span><span class="cov0" title="0">{
                        defaults.UpdateMany = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_PATCH_MANY, funcName, call.Args[0]); e </span><span class="cov0" title="0">{
                        defaults.PatchMany = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_IMPORT, funcName, call.Args[0]); e </span><span class="cov0" title="0">{
                        defaults.Import = act
                }</span>
                <span class="cov8" title="1">if act, e := parseAction(consts.PHASE_EXPORT, funcName, call.Args[0]); e </span><span class="cov0" title="0">{
                        defaults.Export = act
                }</span>

        }

        <span class="cov8" title="1">return defaults</span>
}

// parseAction parses DSL configuration from an action function's body.
// It extracts Payload, Result types and configuration flags (Enabled, Service, Public)
// from the function literal passed to action methods like Create(), Update(), etc.
//
// Parameters:
//   - phase: The expected phase to match (e.g., consts.PHASE_CREATE, consts.PHASE_LIST)
//   - funcName: The actual function name being called
//   - args: The function call arguments, expected to contain a function literal
//
// Returns:
//   - actionResult: Parsed configuration including payload/result types and flags
//   - bool: true if parsing was successful, false otherwise
//
// The function parses DSL calls within the action function body:
//   - Enabled(true/false): Sets whether the action is enabled
//   - Service(true/false): Sets whether to generate service layer code
//   - Public(true/false): Sets whether the API endpoint is public
//   - Payload[Type]: Sets the request payload type
//   - Result[Type]: Sets the response result type
//
// Example usage in DSL:
//
//        Create(func() {
//            Enabled(true)
//            Service(true)
//            Payload[CreateUserRequest]
//            Result[*User]
//        })
func parseAction(phase consts.Phase, funcName string, expr ast.Expr) (*Action, bool) <span class="cov8" title="1">{
        var payload string
        var result string
        var enabled bool // default to false
        var service bool // default to true
        var public bool  // default to false

        if phase.MethodName() != funcName </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">flit, ok := expr.(*ast.FuncLit)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">if flit == nil || flit.Body == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov8" title="1">for _, stmt := range flit.Body.List </span><span class="cov8" title="1">{
                if expr, ok := stmt.(*ast.ExprStmt); ok &amp;&amp; expr != nil </span><span class="cov8" title="1">{
                        if call, ok := expr.X.(*ast.CallExpr); ok &amp;&amp; call != nil &amp;&amp; call.Fun != nil </span><span class="cov8" title="1">{

                                // Parse Enabled(true)/Enabled(false)
                                var isEnabledCall bool
                                switch fun := call.Fun.(type) </span>{
                                case *ast.Ident:<span class="cov8" title="1">
                                        // anonymous import: Enabled(true)
                                        if fun != nil &amp;&amp; fun.Name == "Enabled" </span><span class="cov8" title="1">{
                                                isEnabledCall = true
                                        }</span>
                                case *ast.SelectorExpr:<span class="cov8" title="1">
                                        // non-anonymous import: dsl.Enabled(true)
                                        if fun != nil &amp;&amp; fun.Sel != nil &amp;&amp; fun.Sel.Name == "Enabled" </span><span class="cov8" title="1">{
                                                isEnabledCall = true
                                        }</span>
                                }
                                <span class="cov8" title="1">if isEnabledCall &amp;&amp; len(call.Args) &gt; 0 &amp;&amp; call.Args[0] != nil </span><span class="cov8" title="1">{
                                        if identExpr, ok := call.Args[0].(*ast.Ident); ok &amp;&amp; identExpr != nil </span><span class="cov8" title="1">{
                                                // check the argument of Enabled() is true.
                                                enabled = identExpr.Name == "true"
                                        }</span>
                                }

                                // Parse Service(true)/Service(false)
                                <span class="cov8" title="1">var isServiceCall bool
                                switch fun := call.Fun.(type) </span>{
                                case *ast.Ident:<span class="cov8" title="1">
                                        // anonymous import: Service(true)
                                        if fun != nil &amp;&amp; fun.Name == "Service" </span><span class="cov8" title="1">{
                                                isServiceCall = true
                                        }</span>
                                case *ast.SelectorExpr:<span class="cov8" title="1">
                                        // non-anonymous import: dsl.Service(true)
                                        if fun != nil &amp;&amp; fun.Sel != nil &amp;&amp; fun.Sel.Name == "Service" </span><span class="cov0" title="0">{
                                                isServiceCall = true
                                        }</span>
                                }
                                <span class="cov8" title="1">if isServiceCall &amp;&amp; len(call.Args) &gt; 0 &amp;&amp; call.Args[0] != nil </span><span class="cov8" title="1">{
                                        if identExpr, ok := call.Args[0].(*ast.Ident); ok &amp;&amp; identExpr != nil </span><span class="cov8" title="1">{
                                                // check the argument of Service() is true.
                                                service = identExpr.Name == "true"
                                        }</span>
                                }

                                // Parse Public(true)/Public(false)
                                <span class="cov8" title="1">var isPublicCall bool
                                switch fun := call.Fun.(type) </span>{
                                case *ast.Ident:<span class="cov8" title="1">
                                        // anonymous import: Public(false)
                                        if fun != nil &amp;&amp; fun.Name == "Public" </span><span class="cov8" title="1">{
                                                isPublicCall = true
                                        }</span>
                                case *ast.SelectorExpr:<span class="cov8" title="1">
                                        // non-anonymous import: dsl.Public(false)
                                        if fun != nil &amp;&amp; fun.Sel != nil &amp;&amp; fun.Sel.Name == "Public" </span><span class="cov0" title="0">{
                                                isPublicCall = true
                                        }</span>
                                }

                                <span class="cov8" title="1">if isPublicCall &amp;&amp; len(call.Args) &gt; 0 &amp;&amp; call.Args[0] != nil </span><span class="cov8" title="1">{
                                        if identExpr, ok := call.Args[0].(*ast.Ident); ok &amp;&amp; identExpr != nil </span><span class="cov8" title="1">{
                                                // check the argument of Public() is true.
                                                public = identExpr.Name == "true"
                                        }</span>
                                }

                                // Parse Payload[User] or Result[*User].
                                <span class="cov8" title="1">if indexExpr, ok := call.Fun.(*ast.IndexExpr); ok &amp;&amp; indexExpr != nil </span><span class="cov8" title="1">{
                                        var isPayload bool
                                        var isResult bool
                                        var funcName string
                                        switch x := indexExpr.X.(type) </span>{
                                        case *ast.Ident:<span class="cov8" title="1">
                                                // anonymous import: Payload[User]
                                                if x != nil </span><span class="cov8" title="1">{
                                                        funcName = x.Name
                                                }</span>
                                        case *ast.SelectorExpr:<span class="cov8" title="1">
                                                // non-anonymous import: dsl.Payload[User]
                                                if x != nil &amp;&amp; x.Sel != nil </span><span class="cov8" title="1">{
                                                        funcName = x.Sel.Name
                                                }</span>
                                        }
                                        <span class="cov8" title="1">switch funcName </span>{
                                        case "Payload":<span class="cov8" title="1">
                                                isPayload = true</span>
                                        case "Result":<span class="cov8" title="1">
                                                isResult = true</span>
                                        }
                                        <span class="cov8" title="1">if isPayload </span><span class="cov8" title="1">{
                                                if ident, ok := indexExpr.Index.(*ast.Ident); ok &amp;&amp; ident != nil </span><span class="cov8" title="1">{ // Payload[User]
                                                        payload = ident.Name
                                                }</span> else<span class="cov8" title="1"> if starExpr, ok := indexExpr.Index.(*ast.StarExpr); ok &amp;&amp; starExpr != nil </span><span class="cov8" title="1">{ // Payload[*User]
                                                        if ident, ok := starExpr.X.(*ast.Ident); ok &amp;&amp; ident != nil </span><span class="cov8" title="1">{
                                                                payload = "*" + ident.Name
                                                        }</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if isResult </span><span class="cov8" title="1">{
                                                if ident, ok := indexExpr.Index.(*ast.Ident); ok &amp;&amp; ident != nil </span><span class="cov8" title="1">{ // Result[User]
                                                        result = ident.Name
                                                }</span> else<span class="cov8" title="1"> if starExpr, ok := indexExpr.Index.(*ast.StarExpr); ok &amp;&amp; starExpr != nil </span><span class="cov8" title="1">{ // Result[*User]
                                                        if ident, ok := starExpr.X.(*ast.Ident); ok &amp;&amp; ident != nil </span><span class="cov8" title="1">{
                                                                result = "*" + ident.Name
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return &amp;Action{
                Payload: payload,
                Result:  result,
                Enabled: enabled,
                Service: service,
                Public:  public,
                Phase:   phase,
        }, true</span>
}

// // actionResult holds the parsed configuration for a single DSL action.
// // It contains all the settings that can be configured for an API action
// // through the DSL, including type information and behavioral flags.
// type actionResult struct {
//         // payload is the name of the request payload type (e.g., "CreateUserRequest")
//         payload string
//         // result is the name of the response result type (e.g., "User" or "*User")
//         result string
//         // enabled indicates whether this action should generate API endpoints
//         enabled bool
//         // service indicates whether to generate service layer code for this action
//         service bool
//         // public indicates whether the generated API endpoint should be publicly accessible
//         public bool
// }

// FindAllModelBase finds all struct types that embed model.Base as an anonymous field.
// It searches for structs containing anonymous fields of type "model.Base" or aliased versions
// like "pkgmodel.Base" where pkgmodel is an import alias for the model package.
//
// Parameters:
//   - file: The AST file to search in
//
// Returns:
//   - []string: Names of all struct types that embed model.Base
//
// This function is used to identify models that should have full database functionality,
// as opposed to lightweight models that embed model.Empty.
// FindAllModelBase finds all struct types that embed model.Base as an anonymous field
func FindAllModelBase(file *ast.File) []string <span class="cov8" title="1">{
        names := make([]string, 0)
        if file == nil </span><span class="cov0" title="0">{
                return names
        }</span>
        <span class="cov8" title="1">for _, decl := range file.Decls </span><span class="cov8" title="1">{
                genDecl, ok := decl.(*ast.GenDecl)
                if !ok || genDecl == nil || genDecl.Tok != token.TYPE </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, spec := range genDecl.Specs </span><span class="cov8" title="1">{
                        typeSpec, ok := spec.(*ast.TypeSpec)
                        if !ok || typeSpec == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">structType, ok := typeSpec.Type.(*ast.StructType)
                        if !ok || structType == nil || structType.Fields == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, field := range structType.Fields.List </span><span class="cov8" title="1">{
                                if IsModelBase(file, field) </span><span class="cov8" title="1">{
                                        names = append(names, typeSpec.Name.Name)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return names</span>
}

// FindAllModelEmpty finds all struct types that embed model.Empty as an anonymous field.
// It searches for structs containing anonymous fields of type "model.Empty" or aliased versions
// like "pkgmodel.Empty" where pkgmodel is an import alias for the model package.
//
// Parameters:
//   - file: The AST file to search in
//
// Returns:
//   - []string: Names of all struct types that embed model.Empty
//
// This function is used to identify lightweight models that typically don't require
// database migration and have simplified API generation.
// FindAllModelEmpty finds all struct types that embed model.Empty as an anonymous field
func FindAllModelEmpty(file *ast.File) []string <span class="cov8" title="1">{
        names := make([]string, 0)
        if file == nil </span><span class="cov0" title="0">{
                return names
        }</span>
        <span class="cov8" title="1">for _, decl := range file.Decls </span><span class="cov8" title="1">{
                genDecl, ok := decl.(*ast.GenDecl)
                if !ok || genDecl == nil || genDecl.Tok != token.TYPE </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, spec := range genDecl.Specs </span><span class="cov8" title="1">{
                        typeSpec, ok := spec.(*ast.TypeSpec)
                        if !ok || typeSpec == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">structType, ok := typeSpec.Type.(*ast.StructType)
                        if !ok || structType == nil || structType.Fields == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, field := range structType.Fields.List </span><span class="cov8" title="1">{
                                if IsModelEmpty(file, field) </span><span class="cov8" title="1">{
                                        names = append(names, typeSpec.Name.Name)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return names</span>
}

// IsModelBase checks if a struct field is an anonymous embedding of model.Base.
// It handles various import patterns including direct imports, aliased imports,
// and dot imports of the model package.
//
// Parameters:
//   - file: The AST file containing import information
//   - field: The struct field to check
//
// Returns:
//   - bool: true if the field is an anonymous model.Base embedding
//
// Supported import patterns:
//   - import "github.com/forbearing/gst/model"
//   - import pkgmodel "github.com/forbearing/gst/model"
//   - import . "github.com/forbearing/gst/model"
//
// Example field patterns that return true:
//   - model.Base (with standard import)
//   - pkgmodel.Base (with aliased import)
//   - Base (with dot import)
//
// IsModelBase checks if a struct field is an anonymous embedding of model.Base
func IsModelBase(file *ast.File, field *ast.Field) bool <span class="cov8" title="1">{
        // Not anonymouse field.
        if file == nil || field == nil || len(field.Names) != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">aliasNames := []string{"model"}
        for _, imp := range file.Imports </span><span class="cov8" title="1">{
                if imp.Path == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if imp.Path.Value == consts.IMPORT_PATH_MODEL </span><span class="cov8" title="1">{
                        if imp.Name != nil &amp;&amp; !slices.Contains(aliasNames, imp.Name.Name) </span><span class="cov8" title="1">{
                                aliasNames = append(aliasNames, imp.Name.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">switch t := field.Type.(type) </span>{
        case *ast.SelectorExpr:<span class="cov8" title="1">
                if ident, ok := t.X.(*ast.Ident); ok </span><span class="cov8" title="1">{
                        return slices.Contains(aliasNames, ident.Name) &amp;&amp; t.Sel.Name == "Base"
                }</span>
        case *ast.Ident:<span class="cov0" title="0">
                return t.Name == "Base"</span>
        }

        <span class="cov0" title="0">return false</span>
}

// IsModelEmpty checks if a struct field is an anonymous embedding of model.Empty.
// It handles various import patterns including direct imports, aliased imports,
// and dot imports of the model package.
//
// Parameters:
//   - file: The AST file containing import information
//   - field: The struct field to check
//
// Returns:
//   - bool: true if the field is an anonymous model.Empty embedding
//
// Supported import patterns:
//   - import "github.com/forbearing/gst/model"
//   - import pkgmodel "github.com/forbearing/gst/model"
//   - import . "github.com/forbearing/gst/model"
//
// Example field patterns that return true:
//   - model.Empty (with standard import)
//   - pkgmodel.Empty (with aliased import)
//   - Empty (with dot import)
//
// IsModelEmpty checks if a struct field is an anonymous embedding of model.Empty
func IsModelEmpty(file *ast.File, field *ast.Field) bool <span class="cov8" title="1">{
        // Not anonymouse field.
        if file == nil || field == nil || len(field.Names) != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">aliasNames := []string{"model"}
        for _, imp := range file.Imports </span><span class="cov8" title="1">{
                if imp.Path == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if imp.Path.Value == consts.IMPORT_PATH_MODEL </span><span class="cov8" title="1">{
                        if imp.Name != nil &amp;&amp; !slices.Contains(aliasNames, imp.Name.Name) </span><span class="cov8" title="1">{
                                aliasNames = append(aliasNames, imp.Name.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">switch t := field.Type.(type) </span>{
        case *ast.SelectorExpr:<span class="cov8" title="1">
                if ident, ok := t.X.(*ast.Ident); ok </span><span class="cov8" title="1">{
                        return slices.Contains(aliasNames, ident.Name) &amp;&amp; t.Sel.Name == "Empty"
                }</span>
        case *ast.Ident:<span class="cov0" title="0">
                return t.Name == "Empty"</span>
        }

        <span class="cov0" title="0">return false</span>
}

// starName converts a type name to its pointer equivalent.
// If the name already starts with '*', it removes any existing '*' prefix first
// to avoid double pointers, then adds a single '*' prefix.
//
// Parameters:
//   - name: The type name to convert (e.g., "User", "*User")
//
// Returns:
//   - string: The pointer type name (e.g., "*User")
//
// Examples:
//   - starName("User") returns "*User"
//   - starName("*User") returns "*User"
//   - starName("") returns ""
func starName(name string) string <span class="cov8" title="1">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("*%s", strings.TrimPrefix(name, `*`))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
