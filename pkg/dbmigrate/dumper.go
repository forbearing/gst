package dbmigrate

import (
	"database/sql"
	"reflect"
	"sort"
	"strings"
	"sync"

	"github.com/cockroachdb/errors"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/forbearing/gst/config"
	"github.com/maxrichie5/go-sqlfmt/sqlfmt"
	"gorm.io/driver/mysql"
	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type SchemaDumper struct {
	log  logger.Interface
	db   *sql.DB
	mock sqlmock.Sqlmock

	mu sync.Mutex
}

func NewSchemaDumper() (*SchemaDumper, error) {
	db, mock, err := sqlmock.New()
	if err != nil {
		return nil, err
	}
	return &SchemaDumper{
		db:   db,
		mock: mock,
		log:  &dumperLogger{},
	}, nil
}

func (s *SchemaDumper) Dump(driver config.DBType, dst ...any) (string, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	var dialector gorm.Dialector
	var tableOptions string

	switch driver {
	case config.DBMySQL:
		dialector = mysql.New(mysql.Config{Conn: s.db, SkipInitializeWithVersion: true})
		tableOptions = "ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin"
	case config.DBPostgres:
		dialector = postgres.New(postgres.Config{Conn: s.db, PreferSimpleProtocol: true})
	case config.DBSqlite:
		dialector = sqlite.New(sqlite.Config{Conn: s.db})
		// GORM sqlite driver might ping to check version
		s.mock.ExpectQuery("select sqlite_version()").WillReturnRows(sqlmock.NewRows([]string{"version"}).AddRow("3.35.0"))
	}

	// Sort dst by type name to ensure deterministic output order
	sort.Slice(dst, func(i, j int) bool {
		t1 := reflect.TypeOf(dst[i])
		for t1.Kind() == reflect.Pointer {
			t1 = t1.Elem()
		}
		t2 := reflect.TypeOf(dst[j])
		for t2.Kind() == reflect.Pointer {
			t2 = t2.Elem()
		}
		return t1.String() < t2.String()
	})

	db, err := gorm.Open(dialector, &gorm.Config{DryRun: true, Logger: s.log})
	if err != nil {
		return "", err
	}

	for _, v := range dst {
		var tableName string
		if namer, ok := v.(interface{ GetTableName() string }); ok {
			tableName = namer.GetTableName()
		} else {
			rv := reflect.ValueOf(v)
			if rv.Kind() == reflect.Struct {
				if namer, ok := reflect.New(rv.Type()).Interface().(interface{ GetTableName() string }); ok {
					tableName = namer.GetTableName()
				}
			}
		}

		tx := db.Set("gorm:table_options", tableOptions)
		if tableName != "" {
			tx = tx.Table(tableName)
		}
		if err = tx.Migrator().CreateTable(v); err != nil {
			return "", err
		}
	}

	l, ok := s.log.(*dumperLogger)
	if !ok {
		return "", errors.New("invalid logger type")
	}
	sqls := l.SQLs
	if len(sqls) == 0 {
		return "", nil
	}

	var sb strings.Builder

	for _, sql := range sqls {
		// sqldef parser does not support "CREATE INDEX IF NOT EXISTS" or "CREATE UNIQUE INDEX IF NOT EXISTS" syntax generated by GORM.
		// We remove "IF NOT EXISTS" to ensure compatibility with sqldef.
		sql = strings.ReplaceAll(sql, "CREATE INDEX IF NOT EXISTS", "CREATE INDEX")
		sql = strings.ReplaceAll(sql, "CREATE UNIQUE INDEX IF NOT EXISTS", "CREATE UNIQUE INDEX")

		if driver == config.DBPostgres {
			// GORM generates "timestamptz" for time.Time fields, but PostgreSQL stores it as "timestamp with time zone".
			// sqldef compares the desired DDL with the actual database schema string-wise.
			// This mismatch causes sqldef to repeatedly generate "ALTER COLUMN ... TYPE timestamp with time zone" statements,
			// thinking the schema has changed. We normalize it here to prevent unnecessary migrations.
			sql = strings.ReplaceAll(sql, "timestamptz", "timestamp with time zone")
		}
		if driver == config.DBMySQL {
			// GORM generates "boolean" for bool fields, but MySQL stores it as "tinyint(1)".
			// sqldef compares the desired DDL with the actual database schema string-wise.
			// This mismatch causes sqldef to repeatedly generate "ALTER COLUMN ... TYPE boolean" statements,
			// thinking the schema has changed. We normalize it here to prevent unnecessary migrations.
			sql = strings.ReplaceAll(sql, " boolean ", " tinyint(1) ")
			sql = strings.ReplaceAll(sql, "DEFAULT true", "DEFAULT 1")
			sql = strings.ReplaceAll(sql, "DEFAULT false", "DEFAULT 0")
		}
		if _, err := sb.WriteString(sqlfmt.Format(sql) + ";\n"); err != nil {
			return "", err
		}
	}

	return sb.String(), nil
}

func (s *SchemaDumper) Close() (err error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.db != nil {
		err = s.db.Close()
		s.db = nil
		return err
	}

	return nil
}
